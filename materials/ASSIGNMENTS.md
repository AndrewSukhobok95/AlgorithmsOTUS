# Assignments

### Assignment 1:

**Система тестирования и квадратные заклинания**

- Цель: Создать систему тестирования на основе файлов с начальными данными и результатами. Решить две задач и проверить их решение по тестам, с помощью созданной системы. Посмотреть видеоурок «Квадрат Гарри Поттера» и разгадать дюжину заклинаний. https://www.youtube.com/watch?v=KmV3aBHfo5w
- Все проекты разместить на github или gitlab.
- В чат с преподователем выложить ссылку на репозиторий.
- Заклинания выписать в отдельном файле и пронумеровать.
- Написать, какие пункты выполнены и сколько байт набрано.
- Написать, сколько времени ушло на выполнение задания.
- Критерии оценки:
    - +4 байта - создана система тестирования и проверена на задаче 0.String
    - +3 байта - решена задача 1.Tickets (по 1 байту за каждые три теста).
    - +3 байта - разгадана дюжина заклинаний (по 1 байту за каждую четвёрку).

### Assignment 2:

**НОД, Степень, Простые числа, Числа Фибоначчи**

- Цель: Написать и сравнить разные алгоритмы нахождения наибольшего общего делителя, возведения числа в целую степень, поиска простых чисел и вычисления чисел фибоначчи.
- Написать следующие алгоритмы и сравнить их быстродействие и результаты.
- Приложить скриншоты/ссылки на сравнительную таблицу проведённых экспериментов.
- На выбор: 1 или 2 задание, а также 3 или 4.

1. Алгоритм Евклида поиска НОД макс. 4 байта
    - 1a. Через вычитание
    - 1b. +1 байт Через остаток
    - 1c. +1 байт Через битовые операции
    - +2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
    - Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

2. Алгоритм возведения в степень макс. 4 байта
    - 2а. Итеративный (n умножений)
    - +1 байт 2b. Через степень двойки с домножением
    - +1 байт 2c. Через двоичное разложение показателя степени.
    - +2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
    - Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

3. Алгоритмы поиска кол-ва простых чисел до N макс. 6 байт
    - 3a. Через перебор делителей.
    - +1 байт 3b. Несколько оптимизаций перебора делителей, с использованием массива.
    - +1 байт 3c. Решето Эратосфена со сложностью O(n log log n).
    - +1 байт 3d. Решето Эратосфена с оптимизацией памяти: битовая матрица, по 32 значения в одном int
    - +1 байт 3e. Решето Эратосфена со сложностью O(n)
    - +2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
    - Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

4. Алгоритм поиска чисел Фибоначчи макс. 6 байта
    - 4a. Через рекурсию
    - +1 байт 4b. Через итерацию
    - +1 байт 4c. По формуле золотого сечения
    - +2 байт 4d. Через умножение матриц
    - +2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
    - Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

### Assignment 3:

**Шахматные биты**

- Цель: Решить 4 задачи по условию. Проверить решения по тестам. Приложить ссылку на репозиторий. Написать, что было самое сложное и сколько времени ушло на выполнение задания.
- 1 задача +2 байта
- 2 задача +2 байта
- 3 задача +2 байта
- 4 задача +4 байта

### Assignment 4:

**Динамические массивы, неполный массив, очередь с приоритетом.**

- Цель: Создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной очереди или неполного массива.

1) Динамические массивы.
    - Написать метод добавления и удаления элементов по индексу:
        - `void add(T item, int index);`
        - `T remove(int index); // возвращает удаляемый элемент`
    - Во все варианты динамических массивов:
        - `SingleArray`
        - `VectorArray`
        - `FactorArray`
        - `MatrixArray` (+3 байта)

2) Таблица сравнения производительности. (+3 байта)
    - Сравнить время выполнения разных операций для разных массивов с разным порядком значений.
    - Сделать обёртку над ArrayList() и тоже сравнить.
    - Составить таблицу и приложить её скриншот.
    - Сделать выводы и сформулировать их в нескольких предложениях.

3) Приоритетная очередь (на выбор). (+4 байта)
    - Написать реализацию PriorityQueue - очередь с приоритетом.
    - Варианты реализации - список списков, массив списков
    - Методы к реализации:
    - `enqueue(int priority, T item)` - поместить элемент в очередь
    - `T dequeue()` - выбрать элемент из очереди

4) Неполный массив (на выбор). (+4 байта)
    - Написать Реализацию класса SpaceArray массив массивов с неполным заполнением.
    - Делать на основе одного из уже созданных массивов и/или списков.

- Для реализации можно использовать только стандартные массивы [], созданные классы массивов и/или списков. Стандартные коллекции не используем!

- ВАЖНО! При размещении ответа укажите, на каком языке вы выполнили ДЗ. Это поможет нам ускорить его проверку.
- Критерии оценки:
    - 1 задание. Динамические массивы. +3 байта
    - 2 задание. Таблица сравнение производительности. +3 байта
    - 3 задание (на выбор). Приоритетная очередь. +4 байта
    - 4 задание (на выбор). Класс SpaceArray +4 байта

### Assignment 5:

**Алгоритм HeapSort**

- Цель: Реализовать рассмотренные алгоритмы сортировки и сравнить их эффективность.
- 2 байта Реализовать алгоритм `BubbleSort`, `SelectionSort` или `InsertionSort` (два на выбор).
- 3 байта Реализовать алгоритм `ShellSort` с тремя вариантами выбора шагов.
- 3 байта Реализовать алгоритм `HeapSort`.
- 2 байта Простестировать алгоритмы, заполнить таблицу по результатам измерений, написать свой вывод сравнения, какой алгоритм лучше.

- Файл с тестами приложен к заданию (563 мегабайта).
- На первой строчке указан размер массива, на второй строчке через пробел перечислены элементы массива.
- В файл результата записать числа из отсортированный массив в одну строчку через пробел.

- Тестировать алгоритмы следует на массивах таких размеров: 1, 10, 100, 1.000, 10.000, 100.000, 1.000.000, 10.000.000 (этот по желанию)

- И с различным характером данных:
    - а) random - массив их случайных чисел
    - б) digits - массив из случайных цифр
    - в) sorted - на 99% отсортированный массив
    - г) revers - обратно-отсортированный массив

- Напишите, какие пункты вы сделали, сколько байт набрали и сколько ушло времени на каждый пункт.
- Приложите ссылку на ваш код и на заполненную таблицу.

### Assignment 6:

**Сортировка** Миллиарда чисел

- Цель: Отсортировать миллиард чисел двумя способами: внешней и линейной сортировкой.
    1. Сгенерировать бинарный файл, который содержит N целых, 16-битных чисел (от 0 до 65535), по 2 байта на каждое число. Подобрать N для вашего языка программирования: 1e6, 1e7, 1e8, 1e9 или даже больше.
    2. Написать алгоритм сортировки слиянием для сортировки файла - внешняя сортировка и замерить время его работы.
    3. Использовать для сортировки небольших кусков (от 32 до 1024 чисел) другой алгоритм сортировки на выбор (quick, heap, shell) и сравнить время сортировки "комбинированным" алгоритмом.
    4. Отсортировать числа одним из методов линейной сортировки, написать, какой выбрали:
        - а. Блочная сортировка.
        - б. Сортировка подсчётом.
        - в. Поразрядная сортировка.
    5. Опубликовать таблицу сравнения быстродействия алгоритмов 2, 3 и 4, сделать выводы.

- Написать, сколько ушло времени на выполнение каждого пункта и всего.
- Опубликовать ссылку на репозиторий, таблицу сравнения и вывод.
- Критерии оценки:
    - +2 байта за генерацию файла с числами
    - +2 байта за алгоритм сортировки слиянием файла
    - +2 байта за доп. алгоритм сортировки в памяти
    - +4 байт блочная сортировка (на выбор)
    - +4 байт сортировка подсчётом (на выбор)
    - +4 байт поразрядная сортировка (на выбор)
    - +2 байт сравнительный анализ, заполненная таблица и вывод.

### Assignment 7:

**Двоичное дерево поиска, АВЛ и Декартово дерево**

- Цель: Создать двоичное дерево поиска, реализовать один из вариантов балансировки. Сравнить эффективность алгоритмов на случайных и упорядоченных данных.

- 1 часть, обязательная. 5 байтов.
    - Создать простейшее двоичное дерево поиска. +3 байта.
    - Методы к реализации:
        - `void insert(int x)` - вставка элемента
        - `bool search(int x)` - поиск элемента
        - `void remove(int x)` - удаление элемента

- Протестировать работу алгоритма. +1 байт.
- Создать два дерева (максимальный размер дерева выберите такой, чтобы программа работала не дольше 1 минуты)
- Добавить N чисел в случайном (первое) и возрастающем (второе) порядке.
- Искать N/10 случайных чисел в каждом дереве.
- Удалить N/10 случайных элементов в каждом дереве.

- Заполнить таблицу производительности и сделать вывод. +1 байт. Написать, сколько потребовалось времени.

- 2 часть, на выбор. 5 байтов.
    - Расширить класс из 1 части и создать сбалансированное АВЛ-дерево. +4 байта.
    - Методы к реализации:
        - `smallLeftRotation(Tree t)`, `smallRightRotation(Tree t)` - малое левое/правое вращение
        - `bigLeftRotation(Tree t)`, `bigRightRotation(Tree t)` - большое левое/правое вращение, написать через вызов малых вращений
        - (при желании выполнить оптимизацию: переписать через прямые присваивания и проверить эффективность)
        - `void insert(int x)` - вставка элемента
        - `void remove(int x)` - удаление элемента
        - `void rebalance(Tree t)` - перебалансировка дерева

- Протестировать работу алгоритма аналогичным образом, дополнить таблицу производительности, сделать вывод +1 байт. Написать, сколько потребовалось времени.

- 3 часть, на выбор. 5 байтов.
    - Расширить класс из 1 части и создать декартово дерево. +4 байта.
    - Методы к реализации:
        - `Tree merge(Tree l, Tree r)` - объединение двух деревьев
        - `void split(Tree t, int x, out Tree l, out Tree r)` - разделение дерева на две части
        - `void insert(int x)` - добавление элемента
        - `void remove(int x)` - удаление элемента
    - Протестировать работу алгоритма аналогичным образом, дополнить таблицу производительности, сделать вывод +1 байт. Написать, сколько потребовалось времени.

- При необходимости вы можете изменить заголовки методов.
- Критерии оценки:
    - +5 байтов за реализацию простейшего двоичного дерева поиска с тестированием и выводом
    - +5 байтов за реализацию АВЛ-дерева с тестированием и выводом
    - +5 байтов за реализацию Декартово дерева с тестированием и выводом

### Assignment 8:

**Решить олимпиадную задачу "Сумма на отрезке"**

- Ссылка на задачу: http://codeforces.com/gym/100249/
    - Дан массив из N элементов. Нужно научиться находить сумму чисел на любом отрезке.
    - Формат входного файла.
    - Первая строка входного айла содержит два целых числа:
    - N - число чисел в массиве (1 ≤ N ≤ 100 000),
    - K - количество запросов (0 ≤ K ≤ 100 000).
    - Следующие K строк содержат запросы вида:
        1. A i x присвоить i-му элементу массива значение x (1 ≤ i ≤ N, 0 ≤ x ≤ 10^9)
        2. Q L R найти сумму чисел в массиве на позициях от L до R. (1 ≤ L ≤ R ≤ N)
    - Изначально массиве заполнен нулями.
    - Формат выходного файла:
    - На каждый запрос вида Q L R нужно вывести единственное число - сумму на отрезке.

Пример:

```
sum.in
5 9
A 2 2
A 3 1
A 4 2
Q 1 1
Q 2 2
Q 3 3
Q 4 4
Q 5 5
Q 1 5
sum.out
0
2
1
2
0
5
```

Написанную программу отправьте на проверку на сайте http://codeforces.com/gym/100249/

### Assignment 9:

**Хэш-таблицы**

1. Реализовать хеш-таблицу, использующую метод цепочек
2. Или реализовать хеш-таблицу с открытой адресацией
    - дополнительно: реализовать "ленивое" удаление
    - реализовать квадратичный пробинг
- Критерии оценки:
    - 3 балла максимум за основное задание
    - 2 за дополнительное

### Assignment 10:

**Алгоритм Демукрона**

- Реализовать алгоритм Демукрона
- Граф задан вектором смежности `int A[N][Smax]`. Это п.5 в структурах данных в лекции. Отличие только в том, что вершины нумеруются от 0 а не от 1, и номера самой вершины первым столбцом в матрице не будет, будут только номера смежных вершин.

- Задание:
    - Реализовать алгоритм Демукрона
    - Если понадобится использование стека/очереди обязательно применение собственных структур данных из предыдущих занятий
    - Можно использовать стандартный массив [] встроенный в язык

- Выходные данные:
    - Результат должен быть представлен в виде массива int[][] level где первый индекс - номер уровня, на каждом уровне массив, с номерами вершин, принадлежащих этому уровню

- Дополнительное задание 1: Реализовать алгоритм Тарьяна
- Дополнительное задание 2: Реализовать алгоритм поиска мостов или точек сочленения

- ВАЖНО! При размещении ответа укажите, на каком языке вы выполнили ДЗ. Это поможет нам ускорить его проверку.
- Критерии оценки:
    - 1 балл - алгоритм запрограммирован но не работает
    - 2 балла - алгоритм работает верно, но не оптимально, или есть несоответствия требованиям (например, сделано способом, отличным от указанного)
    - 3 балла - алгоритм работает верно и написан максимально эффективно (нет лишних действий замедляющих работу)
    - 1 балл. Задание сдано в срок.
    - 1 балл. Выполнено дополнительное задание 1
    - 1 балл. Выполнено дополнительное задание 2

### Assignment 11:

**Алгоритм Краскала**

- Реализовать алгоритм нахождения минимального остовного дерева

- Граф задан вектором смежности `int A[N][Smax]`. Это п.5 в структурах данных в лекции. Отличие только в том, что вершины нумеруются от 0 а не от 1, и номера самой вершины первым столбцом в матрице не будет, будут только номера смежных вершин.

- Задание:
    - Реализовать алгоритм Краскала
    - Структура Union-Find собственной реализации.
    - Если понадобится использование стека/очереди обязательно применение собственных структур данных из предыдущих занятий
    - Можно использовать стандартный массив [] встроенный в язык

- Выходные данные:
    - Результат должен быть представлен в виде массива Edge[] edges где Edge - класс, содержащий пару вершин, которые соединяет это ребро

```
Edge
{
    int v1;
    int v2;
}
```

- Для любителей компактного хранения можно упаковать в long два int-а :) Тогда результат будет long[] edges.

- Дополнительное задание 1
    - Реализовать алгоритм Прима

- Дополнительное задание 2
    - Реализовать алгоритм Борувки

- Критерии оценки: 
    - 1 балл - алгоритм запрограммирован но не работает
    - 2 балла - алгоритм работает верно, но не оптимально, или есть несоответствия требованиям (например, сделано способом, отличным от указанного)
    - 3 балла - алгоритм работает верно и написан максимально эффективно (нет лишних действий замедляющих работу)
    - 1 балл. Задание сдано в срок.
    - 1 балл. Выполнено дополнительное задание 1
    - 1 балл. Выполнено дополнительное задание

### Assignment 12:

**Алгоритм Дейкстры**

- Реализовать классику всех времен и народов, алгоритм Дейкстры :)

- Граф задан вектором смежности `int A[N][Smax]`. Это п.5 в структурах данных в лекции. Отличие только в том, что вершины нумеруются от 0 а не от 1, и номера самой вершины первым столбцом в матрице не будет, будут только номера смежных вершин

- Задание:
    - Реализовать алгоритм Дейкстры
    - Если понадобится использование дерева/кучи обязательно применение собственных структур данных из предыдущих занятий
    - Можно использовать стандартный массив [] встроенный в язык

- Выходные данные:
    - Результат должен быть представлен в виде массива Edge[] edges где Edge - класс, содержащий пару вершин, которые соединяет это ребро

```
Edge
{
int v1;
int v2;
}
```

- Для любителей компактного хранения можно упаковать в long два int-а :) Тогда результат будет `long[]` edges.

- Дополнительное задание 1 "Расскажи своей бабушке".
    - Рассказать идею алгоритма Дейкстры совей бабушке так, что бы она это поняла. Поделиться своим опытом в слаке. Не забыть приложить ссылку на пост в задании

- Дополнительное задание 2
    - Реализовать алгоритм Флойда-Уоршалла или Беллама-Форда на выбор

- Критерии оценки: 
    - 1 балл - алгоритм запрограммирован но не работает
    - 2 балла - алгоритм работает верно, но не оптимально, или есть несоответствия требованиям (например, сделано способом, отличным от указанного)
    - 3 балла - алгоритм работает верно и написан максимально эффективно (нет лишних действий замедляющих работу)
    - 1 балл. Задание сдано в срок.
    - 1 балл. Выполнено дополнительное задание 1
    - 1 балл. Выполнено дополнительное задание 2












