# Assignments

### Assignment 1:

Система тестирования и квадратные заклинания
Цель: Создать систему тестирования на основе файлов с начальными данными и результатами. Решить две задач и проверить их решение по тестам, с помощью созданной системы. Посмотреть видеоурок «Квадрат Гарри Поттера» и разгадать дюжину заклинаний. https://www.youtube.com/watch?v=KmV3aBHfo5w
Все проекты разместить на github или gitlab.
В чат с преподователем выложить ссылку на репозиторий.
Заклинания выписать в отдельном файле и пронумеровать.
Написать, какие пункты выполнены и сколько байт набрано.
Написать, сколько времени ушло на выполнение задания.
Критерии оценки: +4 байта - создана система тестирования и проверена на задаче 0.String
+3 байта - решена задача 1.Tickets (по 1 байту за каждые три теста).
+3 байта - разгадана дюжина заклинаний (по 1 байту за каждую четвёрку).

### Assignment 2:

НОД, Степень, Простые числа, Числа Фибоначчи
Цель: Написать и сравнить разные алгоритмы нахождения наибольшего общего делителя, возведения числа в целую степень, поиска простых чисел и вычисления чисел фибоначчи.
Написать следующие алгоритмы и сравнить их быстродействие и результаты.
Приложить скриншоты/ссылки на сравнительную таблицу проведённых экспериментов.

На выбор: 1 или 2 задание, а также 3 или 4.

1. Алгоритм Евклида поиска НОД макс. 4 байта
1a. Через вычитание
+1 байт 1b. Через остаток
+1 байт 1c. Через битовые операции
+2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.
2. Алгоритм возведения в степень макс. 4 байта
2а. Итеративный (n умножений)
+1 байт 2b. Через степень двойки с домножением
+1 байт 2c. Через двоичное разложение показателя степени.
+2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

3. Алгоритмы поиска кол-ва простых чисел до N макс. 6 байт
3a. Через перебор делителей.
+1 байт 3b. Несколько оптимизаций перебора делителей, с использованием массива.
+1 байт 3c. Решето Эратосфена со сложностью O(n log log n).
+1 байт 3d. Решето Эратосфена с оптимизацией памяти: битовая матрица, по 32 значения в одном int
+1 байт 3e. Решето Эратосфена со сложностью O(n)
+2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

4. Алгоритм поиска чисел Фибоначчи макс. 6 байта
4a. Через рекурсию
+1 байт 4b. Через итерацию
+1 байт 4c. По формуле золотого сечения
+2 байт 4d. Через умножение матриц
+2 байт Составить сравнительную таблицу времени работы алгоритмов для разных начальных данных.
Написать, какие пункты выполнены и сколько времени ушло на выполнение домашнего задания.

### Assignment 3:

Шахматные биты
Цель: Решить 4 задачи по условию. Проверить решения по тестам. Приложить ссылку на репозиторий. Написать, что было самое сложное и сколько времени ушло на выполнение задания.
1 задача +2 байта
2 задача +2 байта
3 задача +2 байта
4 задача +4 байта

### Assignment 4:

Динамические массивы, неполный массив, очередь с приоритетом.
Цель: Создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной очереди или неполного массива.
1 задание. Динамические массивы.
Написать метод добавления и удаления элементов:
void add(T item, int index);
T remove(int index); // возвращает удаляемый элемент
по индексу во все варианты динамических массивов:
SingleArray, VectorArray, FactorArray, MatrixArray *.
+3 байта

2 задание. Таблица сравнения производительности.
Сравнить время выполнения разных операций
для разных массивов с разным порядком значений.
* сделать обёртку над ArrayList() и тоже сравнить.
Составить таблицу и приложить её скриншот.
Сделать выводы и сформулировать их в нескольких предложениях.
+3 байта

3 задание. Приоритетная очередь (на выбор).
Написать реализацию PriorityQueue - очередь с приоритетом.
Варианты реализации - список списков, массив списков
Методы к реализации:
enqueue(int priority, T item) - поместить элемент в очередь
T dequeue() - выбрать элемент из очереди
+4 байта

4 задание. Неполный массив (на выбор).
Написать Реализацию класса SpaceArray массив массивов с неполным заполнением.
Делать на основе одного из уже созданных массивов и/или списков.
+4 байта дополнительно.

Напишите сколько времени ушло на домашнее задание.

Для реализации можно использовать только стандартные массивы [], созданные классы массивов и/или списков. Стандартные коллекции не используем!

ВАЖНО! При размещении ответа укажите, на каком языке вы выполнили ДЗ. Это поможет нам ускорить его проверку.
Критерии оценки: 1 задание. Динамические массивы. +3 байта
2 задание. Таблица сравнение производительности. +3 байта
3 задание (на выбор). Приоритетная очередь. +4 байта
4 задание (на выбор). Класс SpaceArray +4 байта

### Assignment 5:

Алгоритм HeapSort
Цель: Реализовать рассмотренные алгоритмы сортировки и сравнить их эффективность.
2 байта Реализовать алгоритм BubbleSort, SelectionSort или InsertionSort (два на выбор).
3 байта Реализовать алгоритм ShellSort с тремя вариантами выбора шагов.
3 байта Реализовать алгоритм HeapSort.
2 байта Простестировать алгоритмы, заполнить таблицу по результатам измерений, написать свой вывод сравнения, какой алгоритм лучше.

Файл с тестами приложен к заданию (563 мегабайта).
На первой строчке указан размер массива, на второй строчке через пробел перечислены элементы массива.
В файл результата записать числа из отсортированный массив в одну строчку через пробел.

Тестировать алгоритмы следует на массивах таких размеров:
1, 10, 100, 1.000, 10.000, 100.000, 1.000.000, 10.000.000 (этот по желанию)

И с различным характером данных:
а) random - массив их случайных чисел
б) digits - массив из случайных цифр
в) sorted - на 99% отсортированный массив
г) revers - обратно-отсортированный массив

Напишите, какие пункты вы сделали, сколько байт набрали и сколько ушло времени на каждый пункт.
Приложите ссылку на ваш код и на заполненную таблицу.

### Assignment 6:

Сортировка Миллиарда чисел
Цель: Отсортировать миллиард чисел двумя способами: внешней и линейной сортировкой.
1. Сгенерировать бинарный файл, который содержит N целых, 16-битных чисел (от 0 до 65535), по 2 байта на каждое число.
Подобрать N для вашего языка программирования: 1e6, 1e7, 1e8, 1e9 или даже больше.
2. Написать алгоритм сортировки слиянием для сортировки файла - внешняя сортировка и замерить время его работы.
3. Использовать для сортировки небольших кусков (от 32 до 1024 чисел) другой алгоритм сортировки на выбор (quick, heap, shell) и сравнить время сортировки "комбинированным" алгоритмом.
4. Отсортировать числа одним из методов линейной сортировки, написать, какой выбрали:
а. Блочная сортировка.
б. Сортировка подсчётом.
в. Поразрядная сортировка.
4. Опубликовать таблицу сравнения быстродействия алгоритмов 2, 3 и 4, сделать выводы.
Написать, сколько ушло времени на выполнение каждого пункта и всего.
Опубликовать ссылку на репозиторий, таблицу сравнения и вывод.
Критерии оценки: +2 байта за генерацию файла с числами
+2 байта за алгоритм сортировки слиянием файла
+2 байта за доп. алгоритм сортировки в памяти
+4 байт блочная сортировка (на выбор)
+4 байт сортировка подсчётом (на выбор)
+4 байт поразрядная сортировка (на выбор)
+2 байт сравнительный анализ, заполненная таблица и вывод.

### Assignment 7:

Двоичное дерево поиска, АВЛ и Декартово дерево
Цель: Создать двоичное дерево поиска, реализовать один из вариантов балансировки. Сравнить эффективность алгоритмов на случайных и упорядоченных данных.
1 часть, обязательная. 5 байтов.
Создать простейшее двоичное дерево поиска. +3 байта.
Методы к реализации:
void insert(int x) - вставка элемента
bool search(int x) - поиск элемента
void remove(int x) - удаление элемента

Протестировать работу алгоритма. +1 байт.
Создать два дерева (максимальный размер дерева выберите такой, чтобы программа работала не дольше 1 минуты)
Добавить N чисел в случайном (первое) и возрастающем (второе) порядке.
Искать N/10 случайных чисел в каждом дереве.
Удалить N/10 случайных элементов в каждом дереве.

Заполнить таблицу производительности и сделать вывод. +1 байт.
Написать, сколько потребовалось времени.

2 часть, на выбор. 5 байтов.
Расширить класс из 1 части и создать сбалансированное АВЛ-дерево. +4 байта.
Методы к реализации:
smallLeftRotation(Tree t) smallRightRotation(Tree t) - малое левое/правое вращение
bigLeftRotation(Tree t), bigRightRotation(Tree t) - большое левое/правое вращение, написать через вызов малых вращений
(при желании выполнить оптимизацию: переписать через прямые присваивания и проверить эффективность)
void insert(int x) - вставка элемента
void remove(int x) - удаление элемента
void rebalance(Tree t) - перебалансировка дерева

Протестировать работу алгоритма аналогичным образом,
дополнить таблицу производительности, сделать вывод +1 байт.
Написать, сколько потребовалось времени.

3 часть, на выбор. 5 байтов.
Расширить класс из 1 части и создать декартово дерево. +4 байта.
Методы к реализации:
Tree merge(Tree l, Tree r) - объединение двух деревьев
void split(Tree t, int x, out Tree l, out Tree r) - разделение дерева на две части
void insert(int x) - добавление элемента
void remove(int x) - удаление элемента
Протестировать работу алгоритма аналогичным образом,
дополнить таблицу производительности, сделать вывод +1 байт.
Написать, сколько потребовалось времени.

При необходимости вы можете изменить заголовки методов.
Критерии оценки: +5 байтов за реализацию простейшего двоичного дерева поиска с тестированием и выводом
+5 байтов за реализацию АВЛ-дерева с тестированием и выводом
+5 байтов за реализацию Декартово дерева с тестированием и выводом

